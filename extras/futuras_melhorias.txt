===================================================================
 GUIA DE MELHORIAS PARA ALGORITMOS DE OTIMIZAÇÃO (ACO E AG)
===================================================================

Este documento resume estratégias para aprimorar o desempenho dos
algoritmos de Colônia de Formigas (ACO) e Genético (AG), que atualmente
apresentam performance abaixo do esperado.

PRINCÍPIO CENTRAL: INJETAR CONHECIMENTO DO PROBLEMA (HEURÍSTICAS)
-------------------------------------------------------------------
O problema principal de meta-heurísticas "puras" é o excesso de 
aleatoriedade. Elas se comportam como "buscadores cegos". Para melhorar
o desempenho, precisamos injetar "dicas" e conhecimento específico do 
problema em várias etapas do processo para guiar a busca de forma 
mais inteligente, transformando-os em "exploradores estratégicos".


===================================================================
 MELHORIAS PARA O ALGORITMO DE COLÔNIA DE FORMIGAS (ACO)
===================================================================

1. REFORÇO ELITISTA DO FEROMÔNIO (ALTO IMPACTO)
-------------------------------------------------
- O QUE É: A cada geração, além da atualização normal de feromônio, 
  dê um "bônus" extra de feromônio para o caminho da MELHOR SOLUÇÃO 
  GLOBAL encontrada até o momento (em todas as gerações).

- POR QUE AJUDA: Cria um reforço muito forte nos melhores caminhos já
  descobertos, acelerando a convergência para regiões promissoras do 
  espaço de busca. Garante que o melhor conhecimento não se perca.

- DICA DE IMPLEMENTAÇÃO: No seu método `_atualizar_feromonio`, após a 
  lógica de depósito da melhor formiga da GERAÇÃO, adicione um novo 
  loop que percorre as alocações da `self.melhor_solucao_global` e 
  deposita uma quantidade extra de feromônio (ex: `peso_elitista * qualidade_global`).


2. MELHORAR A INFORMAÇÃO HEURÍSTICA (η)
------------------------------------------
- O QUE É: Sua heurística atual é apenas a preferência do professor. 
  Podemos torná-la mais sofisticada, considerando também a carga 
  horária já atribuída ao professor no momento da decisão.

- POR QUE AJUDA: Isso introduz um balanço. Uma formiga será atraída por
  um professor de alta preferência, mas essa atração será menor se ele
  já estiver muito ocupado. Isso guia as formigas a distribuírem a 
  carga de forma mais equilibrada durante a construção da solução.

- DICA DE IMPLEMENTAÇÃO: No método `_construir_solucao_formiga`, ao
  calcular a `atratividade`, mude a fórmula da heurística.
  - ANTES: heuristica = self.info_heuristica.loc[candidatos, disciplina]
  - DEPOIS (SUGESTÃO): 
    fator_carga = pd.Series({p: 1 / (cargas_atuais[p] + 1) for p in candidatos})
    heuristica_ponderada = self.info_heuristica.loc[candidatos, disciplina] * fator_carga
    atratividade = (feromonio ** self.alfa) * (heuristica_ponderada ** self.beta)


3. USAR UMA LISTA DE CANDIDATOS RESTRITA
------------------------------------------
- O QUE É: Ao escolher um professor para uma disciplina, em vez de 
  avaliar TODOS os professores disponíveis, a formiga primeiro cria 
  uma "lista curta" (Candidate List) com os 5 ou 10 melhores 
  candidatos (baseado na heurística η). A escolha probabilística é 
  feita apenas dentro dessa lista.

- POR QUE AJUDA: Foca o esforço computacional e a busca apenas nas 
  decisões mais promissoras, podando as escolhas obviamente ruins e 
  acelerando a convergência.

- DICA DE IMPLEMENTAÇÃO: No `_construir_solucao_formiga`, após obter a 
  lista de `candidatos_finais`, crie uma nova lista. Calcule a 
  heurística para todos e pegue os `k` maiores valores. Continue o 
  cálculo de probabilidade apenas com essa lista menor.


===================================================================
 MELHORIAS PARA O ALGORITMO GENÉTICO (AG)
===================================================================

1. ELITISMO (IMPACTO ALTÍSSIMO, ESSENCIAL)
-------------------------------------------
- O QUE É: A cada nova geração, copie os `N` melhores indivíduos da 
  geração atual (ex: os 2 melhores) diretamente para a nova geração, 
  sem que eles passem por crossover ou mutação.

- POR QUE AJUDA: GARANTE que a melhor solução encontrada até o momento 
  nunca seja perdida. Sem elitismo, é possível que uma rodada de 
  crossover/mutação "destrua" o melhor indivíduo, fazendo o 
  algoritmo regredir.

- DICA DE IMPLEMENTAÇÃO: No seu método `resolver`, após calcular o 
  fitness de toda a população, encontre os `N` melhores indivíduos e 
  armazene-os. No início do loop de criação da `nova_populacao`, já 
  adicione esses indivíduos de elite a ela. O loop de seleção e 
  reprodução então preenche o resto da população.


2. "SEMEAR" A POPULAÇÃO INICIAL (SEEDING)
------------------------------------------
- O QUE É: Sua população inicial é 100% aleatória, o que 
  provavelmente resulta em soluções terríveis. Em vez disso, "semeie"
  a população: gere, por exemplo, 90% dos indivíduos aleatoriamente, 
  mas crie os 10% restantes usando um algoritmo guloso (greedy) simples.

- POR QUE AJUDA: Dá ao seu AG um "pontapé inicial" com alguns 
  indivíduos de alta qualidade (provavelmente já válidos e com boas 
  preferências). A evolução começa de um patamar muito mais elevado.

- DICA DE IMPLEMENTAÇÃO: Crie um método privado `_criar_individuo_guloso()`.
  Dentro dele, itere sobre as disciplinas. Para cada uma, aloque o 
  professor com a maior preferência que ainda tenha carga horária 
  disponível. No seu método `_gerar_popucacao_inicial`, chame essa 
  função algumas vezes para criar seus primeiros indivíduos "semeados".


3. MECANISMO DE REPARO (ALTERNATIVA À PENALIDADE)
------------------------------------------------
- O QUE É: A função de penalidade funciona, mas pode ser ineficiente.
  Uma alternativa é, após o crossover e a mutação, verificar se um 
  filho é inválido (viola carga horária ou conflito). Se for, em vez 
  de apenas dar a ele um fitness ruim, você tenta "consertá-lo".

- POR QUE AJUDA: Garante que sua população seja sempre composta por 
  indivíduos válidos, tornando a busca muito mais focada e eficiente.

- DICA DE IMPLEMENTAÇÃO: Crie um método `_reparar_cromossomo(cromossomo)`.
  Após gerar um filho, chame esse método. A lógica de reparo pode ser:
  1. Encontre um professor com excesso de carga.
  2. Pegue a disciplina de menor preferência dele.
  3. Realoque essa disciplina para outro professor (aleatório ou o de 
     maior preferência) que tenha capacidade disponível e não gere conflito.
  Repita até que o cromossomo seja válido.


ORDEM DE IMPLEMENTAÇÃO SUGERIDA:
--------------------------------
1. Elitismo (AG) - Mais fácil e maior impacto.
2. Reforço Elitista do Feromônio (ACO) - Relativamente simples e eficaz.
3. Semear a População Inicial (AG) - Muda a qualidade da busca desde o início.
4. Melhorar a Informação Heurística (ACO) - Refina a tomada de decisão das formigas.
5. Mecanismo de Reparo (AG) / Lista de Candidatos (ACO) - Mais complexos, para um ajuste fino final.